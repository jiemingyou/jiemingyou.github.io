[
  {
    "objectID": "convolution.html",
    "href": "convolution.html",
    "title": "Kernel convolutions",
    "section": "",
    "text": "library(jpeg)\nset.seed(123)\n\n\nLoading the image\nReading the image from a jpg file into a raster array. The image is loaded into an array of (500, 500, 3).\n\n# Reading the sample image\nimg <- readJPEG(\"assets/wall.jpg\", native = FALSE)\ndim(img)\n\n[1] 500 500   3\n\n\nPlotting the the raster image.\n\n# Setting up the plotting area\npar(mfrow = c(1,1), mar = c(1,1,1,1))\n\n# Plotting the array\nplot.new()\nas.raster(img) |>\n  rasterImage(xleft = 0, xright = 1, ytop = 0, ybottom = 1)\n\n\n\n\nOriginal photo\n\n\n\n\n\n\n2-D Gaussian kernel\nGaussian blur can be applied by running a convolution using a Gaussian kernel. The two-dimensional Guaissian kernel is defined as \\[\nG(x,y) = \\frac{1}{2 \\pi \\sigma ^2} e^{- \\frac{x^2 + y^2}{2 \\sigma ^2}}\n\\]\nUsing the CDF of normal distribution, we can calculate the convolution matrix by\n\nGenerating a linspace \\(u = \\texttt{linspace}[\\texttt{a}, \\texttt{b}] \\in \\mathbb{R}^n\\)\nUsing \\(u\\) to draw values from the Gaussian \\(\\texttt{CDF}\\)\nCalculating the convolution matrix \\(M\\) by taking the outer product \\(M = uu^\\top \\in \\mathbb{R}^{n \\times n}\\)\n\n\n# Gaussian kernel function\ngaussian_kernel <- function(width, sigma = 1) {\n    if (width%%2 != 1) { stop(\"Even width parameter\") }\n\n    # Boundaries\n    b  <- (width-1)/2\n    a <- -b\n    \n    # Setting up the linspace\n    ax <- seq(a, b, length = width)\n\n    # Draw from gaussian CDF\n    u <- dnorm(ax, sd = sigma)\n\n    # Outer product uu^T and normalization\n    M <- u %o% u\n    M <- M / sum(M)\n\n    return(M)\n}\n\nPlotting an example convolution matrix using width = 81 and sigma = 10.\n\n\nCalculating color values for the plot\n# Modified from: https://stackoverflow.com/a/39118422\nz <- gaussian_kernel(width = 81, sigma = 10)\ncolors <- colorRampPalette(c(\"green\", \"yellow\", \"red\"))(100)\n\nz.facet.range <- ((z[-1, -1] +\n                   z[-1, -ncol(z)] +\n                   z[-nrow(z), -1] +\n                   z[-nrow(z), -ncol(z)]) / 4) |>\n                \n                cut(100)\n\n\n\n# Preparing the variables\nM <- gaussian_kernel(width = 81, sigma = 10)\nx <- y <- seq(-40, 40, length = 81)\n\n# Plotting the 3D surface\npar(mfrow = c(1,1), mar = c(1,1,1,1))\npersp(x, y, M,\n    theta = 135, phi = 30,\n    zlab = \"density\",\n    col = colors[z.facet.range]\n)\n\n\n\n\n3-D representation of the 2-D gaussian convolution\n\n\n\n\n\n\nExtended edge padding\nIn order to calculate convolutions for the edge pixels, we can extend the edges by repeating edge values indefinitely.\n\n\n\n\n\nPadding edge pixels by extension (Michael 2013).\n\n\n\n\nThe following function repeats the edge pixels of a given matrix for a specified mount of times.\n\nedge_extension <- function(mat, pad) {\n    n <- nrow(mat)\n    m <- ncol(mat)\n\n    top   <- c(rep(mat[1,1], pad), mat[1,], rep(mat[1,m], pad))\n    bot   <- c(rep(mat[n,1], pad), mat[n,], rep(mat[n,m], pad))\n    left  <- matrix(rep(mat[1:n, 1], pad), ncol=pad)\n    right <- matrix(rep(mat[1:n, m], pad), ncol=pad)\n    mid   <- cbind(left, mat[1:n,], right)\n\n    new_mat <- rbind(\n        matrix(rep(top, pad), nrow=pad, byrow=TRUE),\n        mid,\n        matrix(rep(bot, pad), nrow=pad, byrow=TRUE)\n    )\n    \n    return(new_mat)\n}\n\nThe function in action\n\nedge_extension(matrix(1:9, ncol=3, byrow=T), pad=2) |>\n  write.table(row.names=F, col.names=F)\n\n1 1 1 2 3 3 3\n1 1 1 2 3 3 3\n1 1 1 2 3 3 3\n4 4 4 5 6 6 6\n7 7 7 8 9 9 9\n7 7 7 8 9 9 9\n7 7 7 8 9 9 9\n\n\n\n\nGaussian blurring\n\n\n\n\n\n\n\n\nReferences\n\nMichael, Plotke. 2013. Image Kernel Convolution, Extend Edge-Handling. Wikipedia. https://en.wikipedia.org/wiki/File:Extend_Edge-Handling.png."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Jieming You",
    "section": "",
    "text": "Latest projects\n\n\nSähkö Nyt\nElectricity price monitoring app for iOS developed entirely with Swift and SwiftUI. Launching early 2023.\n\n\nSanajahti Solver\nDepth-first search algorithm implementation using Python for solving Sanajahti-game. Web-app built using Flask.\n\n\nGlobal Warming analysis\nBayesian Statistics project analysing the global warming trend. HMC (MCMC) simulation written in R and Stan.\n\n\nKernel Convolution study\nUsing simple kernel convolutions to apply e.g., Gaussian Blur on images. Implemented using base R.\n\n\n\n\nUniversity projects\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n\n\nMarket Research Strategy project conducted for Supermetrics. Research results and suggestions presented to the CEO.\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n\n\nOperations Management Operations optimization for Finnair Kitchen. We mapped the the current processes and designed a new set of KPI for the management.\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n\n\nMetro Optimization We aimed to increase Helsinki metro peak capacity by optimizing people flow using computer vision. Prototype presented to the HSL.\n\n\n\n\nOther stuff\n\n\nDeep Dive Case competition  1st place\nDeep tech Research-to-Business (R2B) case competition.\n\n\nOptiver TraderHack Hackathon  finalist\nAlgorithmic trading competition (Cross-Exchange Market Making)."
  },
  {
    "objectID": "sanajahti.html",
    "href": "sanajahti.html",
    "title": "Sanajahti Solver",
    "section": "",
    "text": "Site work in progress…"
  },
  {
    "objectID": "bayesian.html",
    "href": "bayesian.html",
    "title": "Bayesian project",
    "section": "",
    "text": "Site work in progress…"
  },
  {
    "objectID": "convolution.html#loading-the-image",
    "href": "convolution.html#loading-the-image",
    "title": "Kernel convolutions",
    "section": "Loading the image",
    "text": "Loading the image\n500x500 pixels separated into three channels.\n\nimg <- readJPEG(\"assets/wall.jpg\", native = FALSE)\ndim(img)\n\n[1] 500 500   3"
  }
]